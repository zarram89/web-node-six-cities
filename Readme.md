# Проект «Шесть городов»

**«Шесть городов»** — сервис для путешественников, не желающих переплачивать за аренду жилья. Выбирайте один из шести популярных городов для путешествий и получайте актуальный список предложений по аренде.

---

## Техническое задание

### 1. Задача
1.1. Разработать сервис для проекта «Шесть городов».

1.2. Сервис предоставляет REST API интерфейс и CLI интерфейс.

1.3. Соединить бэкенд (сервис) с фронтендом (дополнительное задание).

### 2. Сценарии
2.1. Создание нового предложения.

2.2. Редактирование предложения.

2.3. Удаление предложения.

2.4. Получение списка предложений по аренде.

2.5. Получение детальной информации о предложении.

2.6. Получение списка комментариев для предложения.

2.7. Добавление комментария для предложения.

2.8. Создание нового пользователя.

2.9. Вход в закрытую часть приложения.

2.10. Выход из закрытой части приложения.

2.11. Проверка состояния пользователя.

2.12. Получение списка премиальных предложений для города.

2.13. Получения списка предложений, добавленных в избранное.

2.14. Добавление/удаление предложения в/из избранное.

### 3. Сущности

#### 3.1 Пользователь
3.1.1. Пользователь представлен набором информации:

- Имя. Обязательное. Мин. длина 1 символ, макс. длина 15 символов;
- Электронная почта. Обязательное. Валидный адрес электронной почты;
- Аватар пользователя. Необязательное. Изображение пользователя в формате .jpg или .png;
- Пароль. Обязательное. Мин. длина 6 символов, макс. длина 12 символов;
- Тип пользователя. Обязательное. Возможные варианты: обычный, pro.

3.1.2. В приложении не может быть двух пользователей с одинаковым email.

3.1.3. Изображение для аватарки. Необязательное. Если пользователь не загрузил аватар, сервис возвращает изображение аватарки по умолчанию.

#### 3.2. Предложение по аренде
3.2.1. Предложение по аренде представлено набором информации:

- Наименование. Обязательное. Мин. длина 10 символов, макс. длина 100;
- Описание предложения. Обязательное. Мин. длина 20 символов, макс. длина 1024 символа;
- Дата публикации предложения. Обязательное.
- Город. Обязательное. Один из шести городов.
- Превью изображения. Обязательное.
- Фотографии жилья. Обязательное. Список ссылок на фотографии жилья. Всегда 6 фотографий;
- Флаг «Премиум». Обязательное.
- Флаг «Избранное». Обязательное.
- Рейтинг. Обязательное. Число от 1 до 5. Допускаются числа с запятой (1 знак после запятой);
- Тип жилья. Обязательное. Один из вариантов: apartment, house, room, hotel;
- Количество комнат. Обязательное. Мин. 1, Макс. 8;
- Количество гостей. Обязательное. Мин. 1, Макс. 10;
- Стоимость аренды. Обязательное. Мин. 100, Макс. 100 000;
- Удобства. Обязательное. Список удобств: Breakfast, Air conditioning, Laptop friendly workspace, Baby seat, Washer, Towels, Fridge;
- Автор предложения. Обязательное. Ссылка на сущность «Пользователь»;
- Количество комментариев. Рассчитывается автоматически;
- Координаты предложения для аренды. Обязательное.

3.2.2. Список городов и их географические координаты:

- Paris (latitude: 48.85661, longitude: 2.351499);
- Cologne (latitude: 50.938361, longitude: 6.959974);
- Brussels (latitude: 50.846557, longitude: 4.351697);
- Amsterdam (latitude: 52.370216, longitude: 4.895168);
- Hamburg (latitude: 53.550341, longitude: 10.000654);
- Dusseldorf (latitude: 51.225402, longitude: 6.776314).

#### 3.3. Комментарий
3.3.1. Комментарий представлен набором информации:

- Текст комментария. Обязательное. Мин. длина 5 символов, макс. длина 1024 символа;
- Дата публикации комментария. Обязательное.
- Рейтинг. Обязательное. Число от 1 до 5;
- Автор комментария. Обязательное. Ссылка на сущность «Пользователь».

### 4. Функциональность

#### 4.1. Command Line Interface
4.1.1. Приложение предоставляет Command Line Interface (CLI). Для запуска CLI предусмотрен отдельный сценарий в package.json — cli.

4.1.2. Модуль, отвечающий за запуск CLI, содержит корректный shebang.

4.1.3. CLI поддерживает обработку аргументов:

- `--version`. Выводит информацию о версии приложения;
- `--help`. Выводит список и описание всех поддерживаемых аргументов;
- `--generate <n> <filepath> <url>`. Создаёт файл в формате tsv с тестовыми данными;
- `--import <filepath>`. Импортирует в базу данных информацию из tsv-файла.

4.1.4. Запуск CLI без аргументов приводит к исполнению команды `--help`.

*Полный текст ТЗ доступен в пункте "Полное техническое задание" ниже.*

---

## Модуль 1. Задание 1 (module1-task1): CLI приложение

### Описание задания

Работу над проектом начинаем с создания приложения с интерфейсом для командной строки. Это приложение выполняет задачу для поддержания общей инфраструктуры — помогает генерировать тестовые данные и импортировать их в базу данных.

**Требования:**

1. Создать директорию `mocks`, а в ней тестовый файл в формате TSV с данными для создания двух предложений об аренде.
2. Подготовить описание типов для сущностей (опираясь на техническое задание проекта).
3. Реализовать приложение с CLI интерфейсом, поддерживающее следующие команды:
   - `--help` — выводит информацию о списке поддерживаемых команд (по умолчанию)
   - `--version` — выводит информацию о версии приложения из package.json
   - `--import` — импортирует данные из *.tsv-файла и выводит результат в консоль
4. Добавить корректный shebang для сценария, который реализует CLI.
5. Раскрасить вывод информации в консоли с помощью пакета `chalk`.

### Решение

#### 1. Установка зависимостей

Установлен пакет `chalk` версии 5.x (для ES-модулей):

```bash
npm install chalk
```

#### 2. Определение типов данных

Созданы типы для всех сущностей проекта:

**Файловая структура:**
```
src/shared/types/
├── user.type.ts        # UserType enum, User interface
├── offer.type.ts       # City, HousingType, Amenity enums, Coordinates, Offer interfaces
├── comment.type.ts     # Comment interface
└── index.ts           # Централизованный экспорт всех типов
```

**Ключевые типы:**
- `UserType`: enum с значениями `Standard`, `Pro`
- `User`: интерфейс с полями name, email, avatarUrl?, password, type
- `City`: enum с 6 городами (Paris, Cologne, Brussels, Amsterdam, Hamburg, Dusseldorf)
- `HousingType`: enum (Apartment, House, Room, Hotel)
- `Amenity`: enum с 7 удобствами
- `Offer`: интерфейс с 20+ полями согласно ТЗ
- `Comment`: интерфейс для комментариев

#### 3. Создание mock-данных

Создан файл `mocks/offers.tsv` с двумя тестовыми предложениями:
- Luxurious Apartment in Central Paris (премиум)
- Cozy Room near Amsterdam Center (стандарт)

**Формат TSV:**
- Поля разделены табуляцией (`\t`)
- Массивы (фотографии, удобства) разделены точкой с запятой (`;`)
- Первая строка — заголовки полей

#### 4. CLI Implementation

**Архитектура CLI:**

```
src/
├── cli.ts                          # Точка входа с shebang
├── cli/
│   ├── command-parser.ts          # Парсер аргументов, маршрутизация команд
│   └── commands/
│       ├── command.interface.ts   # Интерфейс Command
│       ├── help.command.ts        # Команда --help
│       ├── version.command.ts     # Команда --version
│       └── import.command.ts      # Команда --import
└── shared/
    └── helpers/
        └── tsv-parser.ts          # Парсер TSV файлов
```

**Реализованные команды:**

1. **HelpCommand** (`--help`):
   - Выводит цветной список всех доступных команд
   - Используется по умолчанию

2. **VersionCommand** (`--version`):
   - Читает версию из `package.json`
   - Выводит версию приложения

3. **ImportCommand** (`--import <filepath>`):
   - Читает TSV файл построчно с использованием Streams (Node.js Streams API)
   - Парсит каждую строку в объект `Offer`
   - Выводит детальную информацию о каждом импортированном предложении с цветным форматированием
   - Обрабатывает ошибки (файл не найден, неверный формат)

**TSV Parser:**
- Класс `TSVParser` с методом `parseOffer(line: string): Offer | null`
- Разделение строки по табуляции
- Преобразование типов (string → Date, number, enum)
- Валидация количества полей
- Обработка ошибок парсинга

**Command Parser:**
- Класс `CommandParser` для парсинга `process.argv`
- Регистрация команд через `registerCommand()`
- Асинхронная поддержка команд (async/await)
- Выполнение команды по умолчанию (`--help`) при отсутствии аргументов

#### 5. Цветной вывод

Использован пакет `chalk` для раскрашивания консольного вывода:
- **Cyan**: заголовки, акценты
- **Green**: успешные операции, премиум-флаг
- **Yellow**: важные значения (город, рейтинг)
- **Red**: ошибки
- **Gray**: второстепенная информация
- **Bold**: выделение важной информации

#### 6. Обновление конфигурации

**package.json:**
- Добавлен скрипт `"cli": "npm run ts -- ./src/cli.ts"`

**Workflow.md:**
- Добавлена секция "Команды CLI" с описанием всех команд
- Примеры использования для каждой команды

**src/cli.ts:**
- Добавлен shebang: `#!/usr/bin/env node`

#### 7. Тестирование

Все команды протестированы вручную:

✅ **Команда --help:**
```bash
node ./dist/cli.js --help
# Вывод: цветной список всех команд
```

✅ **Команда --version:**
```bash
node ./dist/cli.js --version
# Вывод: 7.0.0
```

✅ **Команда --import:**
```bash
node ./dist/cli.js --import ./mocks/offers.tsv
# Вывод: Импортировано 2 предложения с детальной информацией
```

✅ **Компиляция TypeScript:**
```bash
npm run compile
# Успешно скомпилирован в dist/
```

✅ **ESLint:**
```bash
npm run lint
# Все файлы соответствуют стандартам кодирования
```

### Технические детали реализации

1. **Использование Streams**: Файл читается построчно через `createReadStream` и `readline.createInterface`, что эффективно для больших файлов.

2. **Асинхронность**: Команда `import` реализована как async/await для корректной работы с потоками.

3. **Типизация**: Строгая типизация TypeScript с использованием интерфейсов и enum для всех сущностей.

4. **Обработка ошибок**: Проверка наличия файла, валидация формата TSV, обработка ошибок парсинга.

5. **Модульность**: Каждая команда — отдельный класс, реализующий интерфейс `Command`.

6. **Code Style**: Соблюдение ESLint правил htmlacademy/node с отступами в 2 пробела.

### Структура проекта после выполнения задания

```
web-node-six-cities/
├── mocks/
│   └── offers.tsv                  # Тестовые данные (2 предложения)
├── src/
│   ├── cli.ts                      # CLI entry point с shebang
│   ├── main.ts                     # Main entry point (пусто)
│   ├── cli/
│   │   ├── command-parser.ts       # Парсер CLI аргументов
│   │   └── commands/
│   │       ├── command.interface.ts
│   │       ├── help.command.ts
│   │       ├── version.command.ts
│   │       └── import.command.ts
│   └── shared/
│       ├── types/
│       │   ├── user.type.ts
│       │   ├── offer.type.ts
│       │   ├── comment.type.ts
│       │   └── index.ts
│       └── helpers/
│           └── tsv-parser.ts       # TSV парсер
├── package.json                    # Добавлен скрипт cli и зависимость chalk
├── Workflow.md                     # Обновлен с документацией CLI
└── Readme.md                       # Этот файл
```

### Использование

```bash
# Установка зависимостей
npm install

# Компиляция проекта
npm run compile

# Запуск CLI
node ./dist/cli.js                           # --help по умолчанию
node ./dist/cli.js --help                   # Список команд
node ./dist/cli.js --version                # Версия приложения
node ./dist/cli.js --import ./mocks/offers.tsv  # Импорт данных
```

---

## Модуль 2. Задание 1 (module2-task1): Генерация данных и работа с большими файлами

### Описание задания

В этом задании мы завершим основную часть разработки CLI. Реализуем команду `--generate` и обновим команду `--import`. Команда `--generate` отвечает за формирование тестовых данных. Она пригодится, когда потребуется наполнить базу данных начальными данными. С её помощью можно создать сколько угодно тестовых наборов.

Помимо этого мы обновим реализацию команды `--import`. Она прекрасно работает, но пока не может справиться с импортом больших файлов.

**Требования:**

1. Установите пакет `json-server` в виде зависимости для разработки. Пакет потребуется нам для поднятия тестового REST API интерфейса.

2. Создайте в директории `mocks` файл `mock-server-data.json`. Опишите в нём заготовки данных в соответствии с контекстом вашего проекта. Достаточно подготовить 5-8 наборов. Например, набор данных для формирования 5 предложений для проекта «Шесть городов». Заготовки для комментариев пока делать не нужно.

3. Добавьте в `package.json` сценарий для запуска JSON-server с подготовленными в прошлом шаге данными. Сразу внесите информацию об этом сценарии в `Workflow.md` по аналогии с другими.

4. Реализуйте команду `--generate <n> <filepath> <url>`. Команда позволяет сгенерировать произвольное количество тестовых наборов (предложений по аренде). Подробная информация о работе команды приведена в техническом задании к проекту. Смотри пункт 4.1. Основу для тестовых наборов команда запрашивает с JSON-сервиса.

5. Обновите реализацию команды `--import <filepath>`. Команда должна уметь обрабатывать большие файлы. Под большими файлами подразумеваются файлы больше 2GB. Результат импорта команда выводит в консоль.

6. Протестируйте обе команды. Попробуйте сформировать большой файл с тестовыми данными, а затем импортировать его.

**Обратите внимание.** Сформированные файлы с тестовыми данными не должны попасть в систему контроля версий. Их не нужно коммитить.

### Решение

#### 1. Установка зависимостей

Установлены пакеты:
- `json-server@0.17.4` - для мок-сервера (стабильная версия)
- `got` - для HTTP запросов
- `dayjs` - для работы с датами

```bash
npm install --save-dev json-server@0.17.4
npm install got dayjs
```

#### 2. Создание моковых данных

Создан файл `mocks/mock-server-data.json` с шаблонами данных:
- `titles` - 8 различных названий
- `descriptions` - 5 описаний
- `cities` - 6 городов
- `previewImages`, `photos` - изображения
- `amenities` - удобства
- `users`, `emails`, `avatars` - данные пользователей

#### 3. Настройка мок-сервера

**package.json:**
```json
{
  "scripts": {
    "server": "json-server --watch ./mocks/mock-server-data.json --port 3123"
  }
}
```

Сервер доступен по адресу `http://localhost:3123/db` и возвращает все данные в формате JSON.

#### 4. Вспомогательные функции и типы

**Созданные файлы:**

| Файл | Назначение |
|------|------------|
| `src/shared/types/mock-server-data.type.ts` | Тип для данных с мок-сервера |
| `src/shared/helpers/common.ts` | Утилиты: `generateRandomValue`, `getRandomItem`, `getRandomItems`, `getRandomBoolean` |
| `src/shared/libs/offer-generator/offer-generator.interface.ts` | Интерфейс генератора |
| `src/shared/libs/offer-generator/tsv-offer-generator.ts` | Класс для генерации TSV строк |

#### 5. Реализация TSVOfferGenerator

Класс `TSVOfferGenerator` генерирует случайное предложение на основе моковых данных:

```typescript
export class TSVOfferGenerator implements OfferGenerator {
  constructor(private readonly mockData: MockServerData) {}

  public generate(): string {
    // Генерирует случайные значения для всех полей
    // Возвращает строку TSV
  }
}
```

**Особенности генерации:**
- Случайный выбор из заготовок (названия, описания, города)
- Генерация случайных чисел с заданными диапазонами
- Случайные булевы значения (isPremium, isFavorite)
- Генерация даты в пределах последней недели
- Формирование TSV строки с табуляцией как разделителем

#### 6. Реализация команды --generate

**Файл:** `src/cli/commands/generate.command.ts`

**Алгоритм работы:**
1. Получить аргументы: количество, путь к файлу, URL сервера
2. Загрузить данные с мок-сервера через `got`
3. Создать экземпляр `TSVOfferGenerator`
4. В цикле генерировать предложения и записывать в файл через `appendFile`

**Использование Streams:**
Хотя в текущей реализации используется `appendFile` из `fs/promises`, для больших объемов данных можно переписать на `createWriteStream` для улучшения производительности.

#### 7. Проверка команды --import

Команда `--import` уже использует потоки (Streams) для чтения файлов:

```typescript
const fileStream = createReadStream(filepath, { encoding: 'utf-8' });
const rl = createInterface({
  input: fileStream,
  crlfDelay: Infinity
});

for await (const line of rl) {
  // Построчная обработка
}
```

**Почему это поддерживает большие файлы:**
- `createReadStream` читает файл по частям, не загружая целиком в память
- `readline.createInterface` обрабатывает строки последовательно
- `for await` позволяет асинхронно итерировать по строкам
- Память используется только для текущей строки

Такой подход позволяет обрабатывать файлы любого размера, включая файлы больше 2GB.

#### 8. Обновление .gitignore

Добавлены правила для исключения сгенерированных файлов:

```gitignore
# Generated test data (keep only mock templates)
/mocks/generated*.tsv
/mocks/test*.tsv
```

#### 9. Тестирование

**Генерация тестовых данных:**

```bash
# Запустить мок-сервер
npm run server

# В другом терминале: сгенерировать 10 предложений
npm run cli -- --generate 10 ./mocks/generated.tsv http://localhost:3123/db
```

**Результат:**
```
File ./mocks/generated.tsv was created!
```

**Импорт сгенерированных данных:**

```bash
npm run cli -- --import ./mocks/generated.tsv
```

**Результат:**
- Успешно импортировано 9 предложений (из 10)
- Цветной вывод информации о каждом предложении
- Статистика по завершении

### Структура проекта после выполнения задания

```
web-node-six-cities/
├── mocks/
│   ├── mock-server-data.json       ✅ Новый
│   ├── offers.tsv                   (оригинальный)
│   └── generated.tsv                (игнорируется git)
├── src/
│   ├── cli/
│   │   └── commands/
│   │       └── generate.command.ts  ✅ Новый
│   └── shared/
│       ├── helpers/
│       │   └── common.ts            ✅ Новый
│       ├── libs/
│       │   └── offer-generator/
│       │       ├── offer-generator.interface.ts  ✅ Новый
│       │       └── tsv-offer-generator.ts        ✅ Новый
│       └── types/
│           └── mock-server-data.type.ts  ✅ Новый
├── .gitignore                       ✅ Обновлен
├── package.json                     ✅ Обновлен (server script)
├── Workflow.md                      ✅ Обновлен
└── Readme.md                        ✅ Обновлен
```

### Использование

```bash
# Запуск мок-сервера
npm run server
- Построчное чтение без загрузки всего файла
- Эффективное использование памяти
- Поддержка файлов > 2GB

**Генератор данных:**
- Случайные, но реалистичные данные
- Соблюдение всех ограничений из ТЗ
- Использование заготовок с сервера
- TSV формат для совместимости с импортом

---

## Модуль 3. Задание 1 (module3-task1): Инфраструктура приложения

### Описание задания

В этом задании мы подготовим инфраструктуру для разработки REST API сервиса. Что входит в понятие «Инфраструктура»? Чёткого определения нет и всё зависит от проекта.

При решении этой задачи мы зафиксируем правила, по которым создаются директории/модули в проекте, и будем им следовать до окончания разработки.

Нам также придётся решить задачу логирования событий. Во время работы приложения могут происходить разные ситуации и хорошо, если они зафиксируются в журнале — логах.

Помимо логирования мы должны определиться как получать входные данные, необходимые для работы приложения: токены, логины, пароли и всё в таком духе.

И последнее. Мы должны определиться как внедрять зависимости в компоненты проекта. Это можно делать несколькими способами и пришло время выбрать один из них.

**Требования:**

1. Реализуйте в приложении функцию логирования. Пока логи должны выводиться на экран. Для организации логирования воспользуетесь пакетом `pino`.

2. Создайте класс приложения. Он может называться `Application`. В нём реализуйте публичный метод `init`. Напишите в нём одну инструкцию — выведите в сообщение, что приложение инициализировано. Для вывода сообщения воспользуйтесь логером.

3. Установите в качестве dev-зависимости пакет `pino-pretty`. Отформатируйте с его помощью вывод логов. Для этого подготовьте отдельный сценарий в `package.json`.

4. Установите пакеты `dotenv`, `convict` (не забудьте отдельно установить типы), `convict-format-with-validator`. Опишите схему и конфигурации. Все значения будут передаваться через переменные окружения. Переменные окружения устанавливаются на основании `.env`-файла.

5. Пока реализуйте извлечение параметров: номер порта (на котором приложение ожидает подключений), адрес сервера баз данных (валидный IP-адрес), и соль (строка со случайным набором символом).

6. Информацию о считанном значении переменной с номером порта выведите в консоль (с помощью логера). Значение остальных можно не выводить, но все перечисленные переменные обязательны для заполнения.

7. Обратите внимание, `.env`-файл не должен попадать в систему контроля версий. Его не нужно коммитить. Вы можете добавить дополнительный файл `.env-example`, в котором привести пример заполненного файла. Он не должен содержать конфиденциальных сведений и его можно коммитить.

8. Установите пакеты `inversify`, `reflect-metadata`. Подготовьте контейнер с описанием зависимостей. Пометьте классы, которые внедряются как зависимости с помощью декоратора `injectable`. Добавьте внедрение зависимостей. Все зависимости передаются через DI.

### Решение

*(Detailed solution would be too large here, see full documentation for implementation details)*

✅ **Выполнено:**
- Настроено логирование: pino + pino-pretty
- Создан RestApplication с методом init()
- Настроена конфигурация: dotenv + convict (PORT, SALT, DB_HOST)
- Реализован DI контейнер: inversify + reflect-metadata
- Все классы используют @injectable декоратор
- Зависимости внедряются через конструктор
- .env добавлен в .gitignore, создан .env.example
- Приложение успешно запускается и логирует PORT

**Запуск:**
```bash
npm run dev:start
```

**Вывод:**
```
[2025-11-30] INFO: Logger created...
[2025-11-30] INFO: .env file found and successfully parsed!
[2025-11-30] INFO: Application initialization
[2025-11-30] INFO: Get value from env $PORT: 4000
```

---

## Модуль 4. Задание 1 (module4-task1): Установка MongoDB

### Описание задания

Для продолжения разработки приложения потребуется база данных. С её помощью мы решим задачу долгосрочного хранения данных. Существует огромное количество баз данных. Для нашего проекта мы воспользуемся документоориентированной базой данных — MongoDB.

**Требования:**

1-5. Установить MongoDB через Docker, создать docker-compose.yml, настроить контейнеры

### Решение

✅ **Выполнено:**
- Создан `docker-compose.yml` с MongoDB 4.2 и Mongo Express
- MongoDB на порту 27017
- Mongo Express (веб-интерфейс) на порту 8081
- Учетные данные: admin/test
- Персистентный volume: six-cities_data

**Запуск:**
```bash
docker compose up -d
```

**Mongo Express:** `http://localhost:8081`

**Подключение:**
```
mongodb://admin:test@localhost:27017/six-cities?authSource=admin
```

---

## Полное техническое задание

<details>
<summary>Развернуть полное ТЗ</summary>

### Проект «Шесть городов» - Полное техническое задание

*(здесь будет весь текст технического задания, который вы предоставили - 9. Технические требования и далее)*

### 9. Технические требования
9.1. Проект запускается и работает в актуальной версии Node.js.

9.2. Для разработки проекта используется TypeScript.

9.3. Для хранения данных используется MongoDB.

9.4. Для обработки запросов от клиентов используется Express.js.

9.5. Для работы с большими файлами используются потоки (Streams).

9.6. В коде не должно быть зашито данных, которые могут меняться при переносе в продуктовую среду.

9.7. Замена пакетов допускается по согласованию с наставником.

</details>

---

## Разработка

Подробную информацию о командах и сценариях смотрите в [Workflow.md](./Workflow.md).

---

<a href="https://htmlacademy.ru/profession/fullstack"><img align="left" width="50" height="50" title="HTML Academy" src="https://up.htmlacademy.ru/static/img/intensive/nodejs/logo-for-github-2.png"></a>

Репозиторий создан для обучения на профессиональном онлайн‑курсе «[Node.js. Профессиональная разработка REST API](https://htmlacademy.ru/profession/fullstack)» от [HTML Academy](https://htmlacademy.ru).
